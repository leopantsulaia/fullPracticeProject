import {
  require_react_dom
} from "./chunk-G52XTN3B.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment2(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment2;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@reach/menu-button/dist/reach-menu-button.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@reach/popover/dist/reach-popover.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@reach/portal/dist/reach-portal.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@reach/utils/dist/reach-utils.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var React = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function isString(value) {
  return typeof value === "string";
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(`Cannot assign value "${value}" to ref "${ref}"`);
    }
  }
}
function useComposedRefs(...refs) {
  return (0, import_react2.useCallback)((node) => {
    for (let ref of refs) {
      assignRef(ref, node);
    }
  }, refs);
}
function getOwnerDocument(element) {
  return canUseDOM() ? element ? element.ownerDocument : document : null;
}
function createContext2(rootComponentName, defaultContext) {
  let Ctx = React.createContext(defaultContext);
  function Provider(props2) {
    let { children, ...context } = props2;
    let value = React.useMemo(() => context, Object.values(context));
    return React.createElement(Ctx.Provider, {
      value
    }, children);
  }
  function useContext22(callerComponentName) {
    let context = React.useContext(Ctx);
    if (context) {
      return context;
    }
    if (defaultContext) {
      return defaultContext;
    }
    throw Error(`${callerComponentName} must be rendered inside of a ${rootComponentName} component.`);
  }
  Ctx.displayName = `${rootComponentName}Context`;
  Provider.displayName = `${rootComponentName}Provider`;
  return [Provider, useContext22];
}
function isRightClick(nativeEvent) {
  return "which" in nativeEvent ? nativeEvent.which === 3 : "button" in nativeEvent ? nativeEvent.button === 2 : false;
}
function makeId(...args) {
  return args.filter((val) => val != null).join("--");
}
function noop() {
}
function useForceUpdate() {
  let [, dispatch] = (0, import_react8.useState)(/* @__PURE__ */ Object.create(null));
  return (0, import_react8.useCallback)(() => {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
var useIsomorphicLayoutEffect = canUseDOM() ? import_react9.useLayoutEffect : import_react9.useEffect;
function usePrevious(value) {
  const ref = (0, import_react11.useRef)(null);
  (0, import_react11.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function useStatefulRefValue(ref, initialState2) {
  let [state, setState] = (0, import_react13.useState)(initialState2);
  let callbackRef = (0, import_react13.useCallback)((refValue) => {
    ref.current = refValue;
    setState(refValue);
  }, []);
  return [state, callbackRef];
}

// node_modules/@reach/portal/dist/reach-portal.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var PortalImpl = ({
  children,
  type = "reach-portal",
  containerRef
}) => {
  let mountNode = React2.useRef(null);
  let portalNode = React2.useRef(null);
  let forceUpdate = useForceUpdate();
  if (true) {
    React2.useEffect(() => {
      if (containerRef != null) {
        if (typeof containerRef !== "object" || !("current" in containerRef)) {
          console.warn("@reach/portal: Invalid value passed to the `containerRef` of a `Portal`. The portal will be appended to the document body, but if you want to attach it to another DOM node you must pass a valid React ref object to `containerRef`.");
        } else if (containerRef.current == null) {
          console.warn("@reach/portal: A ref was passed to the `containerRef` prop of a `Portal`, but no DOM node was attached to it. Be sure to pass the ref to a DOM component.\n\nIf you are forwarding the ref from another component, be sure to use the React.forwardRef API. See https://reactjs.org/docs/forwarding-refs.html.");
        }
      }
    }, [containerRef]);
  }
  useIsomorphicLayoutEffect(() => {
    if (!mountNode.current)
      return;
    let ownerDocument = mountNode.current.ownerDocument;
    let body = (containerRef == null ? void 0 : containerRef.current) || ownerDocument.body;
    portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type);
    body.appendChild(portalNode.current);
    forceUpdate();
    return () => {
      if (portalNode.current && body) {
        body.removeChild(portalNode.current);
      }
    };
  }, [type, forceUpdate, containerRef]);
  return portalNode.current ? (0, import_react_dom.createPortal)(children, portalNode.current) : React2.createElement("span", {
    ref: mountNode
  });
};
var Portal = ({
  unstable_skipInitialRender,
  ...props2
}) => {
  let [hydrated, setHydrated] = React2.useState(false);
  React2.useEffect(() => {
    if (unstable_skipInitialRender) {
      setHydrated(true);
    }
  }, [unstable_skipInitialRender]);
  if (unstable_skipInitialRender && !hydrated) {
    return null;
  }
  return React2.createElement(PortalImpl, {
    ...props2
  });
};
Portal.displayName = "Portal";

// node_modules/@reach/rect/dist/reach-rect.mjs
var React3 = __toESM(require_react(), 1);

// node_modules/@reach/observe-rect/dist/observe-rect.esm.js
var props = ["bottom", "height", "left", "right", "top", "width"];
var rectChanged = function rectChanged2(a, b) {
  if (a === void 0) {
    a = {};
  }
  if (b === void 0) {
    b = {};
  }
  return props.some(function(prop) {
    return a[prop] !== b[prop];
  });
};
var observedNodes = /* @__PURE__ */ new Map();
var rafId;
var run = function run2() {
  var changedStates = [];
  observedNodes.forEach(function(state, node) {
    var newRect = node.getBoundingClientRect();
    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function(state) {
    state.callbacks.forEach(function(cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run2);
};
function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;
      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: void 0,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }
      if (wasEmpty)
        run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);
      if (state) {
        var index = state.callbacks.indexOf(cb);
        if (index >= 0)
          state.callbacks.splice(index, 1);
        if (!state.callbacks.length)
          observedNodes["delete"](node);
        if (!observedNodes.size)
          cancelAnimationFrame(rafId);
      }
    }
  };
}
var observe_rect_esm_default = observeRect;

// node_modules/@reach/rect/dist/reach-rect.mjs
var Rect = ({ onChange, observe = true, children }) => {
  const ref = React3.useRef(null);
  const rect = useRect(ref, { observe, onChange });
  return children({ ref, rect });
};
Rect.displayName = "Rect";
function useRect(nodeRef, observeOrOptions, deprecated_onChange) {
  let observe;
  let onChange;
  if (isBoolean(observeOrOptions)) {
    observe = observeOrOptions;
  } else {
    observe = (observeOrOptions == null ? void 0 : observeOrOptions.observe) ?? true;
    onChange = observeOrOptions == null ? void 0 : observeOrOptions.onChange;
  }
  if (isFunction(deprecated_onChange)) {
    onChange = deprecated_onChange;
  }
  if (true) {
    React3.useEffect(() => {
      if (isBoolean(observeOrOptions)) {
        console.warn("Passing `observe` as the second argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `observe` property as the second argument (`useRect(ref, { observe })`).\nSee https://reach.tech/rect#userect-observe");
      }
    }, [observeOrOptions]);
    React3.useEffect(() => {
      if (isFunction(deprecated_onChange)) {
        console.warn("Passing `onChange` as the third argument to `useRect` is deprecated and will be removed in a future version of Reach UI. Instead, you can pass an object of options with an `onChange` property as the second argument (`useRect(ref, { onChange })`).\nSee https://reach.tech/rect#userect-onchange");
      }
    }, [deprecated_onChange]);
  }
  let [element, setElement] = React3.useState(nodeRef.current);
  let initialRectIsSet = React3.useRef(false);
  let initialRefIsSet = React3.useRef(false);
  let [rect, setRect] = React3.useState(null);
  let onChangeRef = React3.useRef(onChange);
  useIsomorphicLayoutEffect(() => {
    onChangeRef.current = onChange;
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (element && !initialRectIsSet.current) {
      initialRectIsSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]);
  useIsomorphicLayoutEffect(() => {
    if (!observe) {
      return;
    }
    let elem = element;
    if (!initialRefIsSet.current) {
      initialRefIsSet.current = true;
      elem = nodeRef.current;
    }
    if (!elem) {
      if (true) {
        console.warn("You need to place the ref");
      }
      return;
    }
    let observer = observe_rect_esm_default(elem, (rect2) => {
      var _a;
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, rect2);
      setRect(rect2);
    });
    observer.observe();
    return () => {
      observer.unobserve();
    };
  }, [observe, element, nodeRef]);
  return rect;
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@reach/popover/dist/reach-popover.mjs
var Popover = React4.forwardRef(function Popover2({ unstable_skipInitialPortalRender, ...props2 }, ref) {
  return React4.createElement(Portal, {
    unstable_skipInitialRender: unstable_skipInitialPortalRender
  }, React4.createElement(PopoverImpl, {
    ref,
    ...props2
  }));
});
Popover.displayName = "Popover";
var PopoverImpl = React4.forwardRef(function PopoverImpl2({
  as: Comp = "div",
  targetRef,
  position = positionDefault,
  unstable_observableRefs = [],
  ...props2
}, forwardedRef) {
  const popoverRef = React4.useRef(null);
  const popoverRect = useRect(popoverRef, { observe: !props2.hidden });
  const targetRect = useRect(targetRef, { observe: true });
  const ref = useComposedRefs(popoverRef, forwardedRef);
  useSimulateTabNavigationForReactTree(targetRef, popoverRef);
  return React4.createElement(Comp, {
    "data-reach-popover": "",
    ref,
    ...props2,
    style: {
      position: "absolute",
      ...getStyles(position, targetRect, popoverRect, ...unstable_observableRefs),
      ...props2.style
    }
  });
});
PopoverImpl.displayName = "PopoverImpl";
function getStyles(position, targetRect, popoverRect, ...unstable_observableRefs) {
  return popoverRect ? position(targetRect, popoverRect, ...unstable_observableRefs.map((ref) => ref.current)) : { visibility: "hidden" };
}
function getTopPosition(targetRect, popoverRect, isDirectionUp) {
  return {
    top: isDirectionUp ? `${targetRect.top - popoverRect.height + window.pageYOffset}px` : `${targetRect.top + targetRect.height + window.pageYOffset}px`
  };
}
var positionDefault = (targetRect, popoverRect) => {
  if (!targetRect || !popoverRect) {
    return {};
  }
  const { directionRight, directionUp } = getCollisions(targetRect, popoverRect);
  return {
    left: directionRight ? `${targetRect.right - popoverRect.width + window.pageXOffset}px` : `${targetRect.left + window.pageXOffset}px`,
    ...getTopPosition(targetRect, popoverRect, directionUp)
  };
};
function getCollisions(targetRect, popoverRect, offsetLeft = 0, offsetBottom = 0) {
  const collisions = {
    top: targetRect.top - popoverRect.height < 0,
    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,
    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,
    left: targetRect.left + targetRect.width - popoverRect.width < 0
  };
  const directionRight = collisions.right && !collisions.left;
  const directionLeft = collisions.left && !collisions.right;
  const directionUp = collisions.bottom && !collisions.top;
  const directionDown = collisions.top && !collisions.bottom;
  return { directionRight, directionLeft, directionUp, directionDown };
}
function useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {
  const ownerDocument = getOwnerDocument(triggerRef.current);
  function handleKeyDown(event) {
    if (event.key === "Tab" && popoverRef.current && tabbable(popoverRef.current).length === 0) {
      return;
    }
    if (event.key === "Tab" && event.shiftKey) {
      if (shiftTabbedFromElementAfterTrigger(event)) {
        focusLastTabbableInPopover(event);
      } else if (shiftTabbedOutOfPopover(event)) {
        focusTriggerRef(event);
      } else if (shiftTabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    } else if (event.key === "Tab") {
      if (tabbedFromTriggerToPopover()) {
        focusFirstPopoverTabbable(event);
      } else if (tabbedOutOfPopover()) {
        focusTabbableAfterTrigger(event);
      } else if (tabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    }
  }
  React4.useEffect(() => {
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => {
      ownerDocument.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  function getElementAfterTrigger() {
    const elements = tabbable(ownerDocument);
    const targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;
    const elementAfterTrigger = elements && elements[targetIndex + 1];
    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;
  }
  function tabbedFromTriggerToPopover() {
    return triggerRef.current ? triggerRef.current === ownerDocument.activeElement : false;
  }
  function focusFirstPopoverTabbable(event) {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    if (elements && elements[0]) {
      event.preventDefault();
      elements[0].focus();
    }
  }
  function tabbedOutOfPopover() {
    const inPopover = popoverRef.current ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;
    if (inPopover) {
      const elements = popoverRef.current && tabbable(popoverRef.current);
      return Boolean(elements && elements[elements.length - 1] === ownerDocument.activeElement);
    }
    return false;
  }
  function focusTabbableAfterTrigger(event) {
    const elementAfterTrigger = getElementAfterTrigger();
    if (elementAfterTrigger) {
      event.preventDefault();
      elementAfterTrigger.focus();
    }
  }
  function shiftTabbedFromElementAfterTrigger(event) {
    if (!event.shiftKey)
      return;
    const elementAfterTrigger = getElementAfterTrigger();
    return event.target === elementAfterTrigger;
  }
  function focusLastTabbableInPopover(event) {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    const last = elements && elements[elements.length - 1];
    if (last) {
      event.preventDefault();
      last.focus();
    }
  }
  function shiftTabbedOutOfPopover(event) {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    if (elements) {
      return elements.length === 0 ? false : event.target === elements[0];
    }
    return false;
  }
  function focusTriggerRef(event) {
    var _a;
    event.preventDefault();
    (_a = triggerRef.current) == null ? void 0 : _a.focus();
  }
  function tabbedToBrowserChrome(event) {
    const elements = popoverRef.current ? tabbable(ownerDocument).filter((element) => !popoverRef.current.contains(element)) : null;
    return elements ? event.target === elements[elements.length - 1] : false;
  }
  function shiftTabbedToBrowserChrome(event) {
    return event.target === tabbable(ownerDocument)[0];
  }
  let restoreTabIndexTuplés = [];
  function disableTabbablesInPopover() {
    const elements = popoverRef.current && tabbable(popoverRef.current);
    if (elements) {
      elements.forEach((element) => {
        restoreTabIndexTuplés.push([element, element.tabIndex]);
        element.tabIndex = -1;
      });
      ownerDocument.addEventListener("focusin", enableTabbablesInPopover);
    }
  }
  function enableTabbablesInPopover() {
    ownerDocument.removeEventListener("focusin", enableTabbablesInPopover);
    restoreTabIndexTuplés.forEach(([element, tabIndex]) => {
      element.tabIndex = tabIndex;
    });
  }
}

// node_modules/@reach/dropdown/dist/reach-dropdown.mjs
var React7 = __toESM(require_react(), 1);

// node_modules/@reach/auto-id/dist/reach-auto-id.mjs
var React5 = __toESM(require_react(), 1);
var serverHandoffComplete = false;
var id = 0;
function genId() {
  return ++id;
}
var maybeReactUseId = React5["useId".toString()];
function useId(providedId) {
  if (maybeReactUseId !== void 0) {
    let generatedId = maybeReactUseId();
    return providedId ?? generatedId;
  }
  let initialId = providedId ?? (serverHandoffComplete ? genId() : null);
  let [id2, setId] = React5.useState(initialId);
  useIsomorphicLayoutEffect(() => {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  React5.useEffect(() => {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return providedId ?? id2 ?? void 0;
}

// node_modules/@reach/descendants/dist/reach-descendants.mjs
var React6 = __toESM(require_react(), 1);
function createDescendantContext(name, initialValue = {}) {
  const descendants = [];
  let ctx = React6.createContext({
    descendants,
    registerDescendant: () => noop,
    ...initialValue
  });
  ctx.displayName = name;
  return ctx;
}
function useDescendant(descendant, context, indexProp) {
  let forceUpdate = useForceUpdate();
  let { registerDescendant, descendants } = React6.useContext(context);
  let index = indexProp ?? descendants.findIndex((item) => item.element === descendant.element);
  useIsomorphicLayoutEffect(() => {
    if (!descendant.element)
      forceUpdate();
    return registerDescendant({ ...descendant, index });
  }, [
    descendant,
    forceUpdate,
    index,
    registerDescendant,
    ...Object.values(descendant)
  ]);
  return index;
}
function useDescendantsInit() {
  return React6.useState([]);
}
function useDescendants(ctx) {
  return React6.useContext(ctx).descendants;
}
function DescendantProvider({
  context: Ctx,
  children,
  items,
  set
}) {
  let registerDescendant = React6.useCallback(({
    element,
    index: explicitIndex,
    ...rest
  }) => {
    if (!element)
      return noop;
    set((items2) => {
      if (explicitIndex != null && explicitIndex !== -1) {
        return insertAt(items2, { element, index: explicitIndex, ...rest }, explicitIndex);
      }
      if (items2.length === 0) {
        return [{ ...rest, element, index: 0 }];
      }
      if (true) {
        if (items2.find((item) => item.element === element)) {
          console.warn("[reach-ui]: `useDescendant` was called with an element that was already registered.\n\nIf you are using the `@reach/descendants` package directly, make sure to only register descendants once. Registering a descendant more than once will lead to bugs in your app.\n\nIf you are using another `reach-ui` package, this is probably our bug!\n\nTo report a bug, open a new issue:\n\n  https://github.com/reach/reach-ui/issues/new?assignees=&labels=&template=Bug_report.md\n\nIMPORTANT: this check will only run in the development build, so if you see this warning please be aware that your app may crash when deployed.");
          return updateIndices(items2);
        }
      }
      let index = findDOMIndex(items2, element);
      let newItems;
      if (index === -1) {
        newItems = [
          ...items2,
          { ...rest, element, index: items2.length }
        ];
      } else {
        newItems = insertAt(items2, { ...rest, element, index }, index);
      }
      return newItems;
    });
    return () => {
      if (!element)
        return;
      set((items2) => items2.filter((item) => element !== item.element));
    };
  }, []);
  return React6.createElement(Ctx.Provider, {
    value: React6.useMemo(() => {
      return {
        descendants: items,
        registerDescendant
      };
    }, [items, registerDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  let { descendants } = React6.useContext(context);
  let {
    callback,
    currentIndex,
    filter,
    key = "index",
    orientation = "vertical",
    rotate = true,
    rtl = false
  } = options;
  return function handleKeyDown(event) {
    if (![
      "ArrowDown",
      "ArrowUp",
      "ArrowLeft",
      "ArrowRight",
      "PageUp",
      "PageDown",
      "Home",
      "End"
    ].includes(event.key)) {
      return;
    }
    let index = currentIndex ?? -1;
    let selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (!selectableDescendants.length) {
      return;
    }
    let selectableIndex = selectableDescendants.findIndex((descendant) => descendant.index === currentIndex);
    function getNextOption() {
      let atBottom = index === getLastOption().index;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      let atTop = index === getFirstOption().index;
      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        let prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        let first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        let last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, element) {
  if (!element)
    return -1;
  if (!items.length)
    return -1;
  let length = items.length;
  while (length--) {
    let currentElement = items[length].element;
    if (!currentElement)
      continue;
    if (isElementPreceding(currentElement, element)) {
      return length + 1;
    }
  }
  return -1;
}
function insertAt(array, item, index) {
  if (index == null || !(index in array)) {
    return [...array, item];
  }
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function updateIndices(items) {
  return items.sort((a, b) => !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1).map((item, index) => ({ ...item, index }));
}

// node_modules/@reach/dropdown/dist/reach-dropdown.mjs
var CLEAR_SELECTION_INDEX = "CLEAR_SELECTION_INDEX";
var CLICK_MENU_ITEM = "CLICK_MENU_ITEM";
var CLOSE_MENU = "CLOSE_MENU";
var OPEN_MENU_AT_FIRST_ITEM = "OPEN_MENU_AT_FIRST_ITEM";
var OPEN_MENU_AT_INDEX = "OPEN_MENU_AT_INDEX";
var OPEN_MENU_CLEARED = "OPEN_MENU_CLEARED";
var SEARCH_FOR_ITEM = "SEARCH_FOR_ITEM";
var SELECT_ITEM_AT_INDEX = "SELECT_ITEM_AT_INDEX";
var SET_BUTTON_ID = "SET_BUTTON_ID";
var DropdownDescendantContext = createDescendantContext("DropdownDescendantContext");
var [DropdownProvider, useDropdownContext] = createContext2("Dropdown");
var initialState = {
  triggerId: null,
  isExpanded: false,
  typeaheadQuery: "",
  selectionIndex: -1
};
var DropdownProvider_ = ({
  id: id2,
  children
}) => {
  let triggerRef = React7.useRef(null);
  let dropdownRef = React7.useRef(null);
  let popoverRef = React7.useRef(null);
  let [descendants, setDescendants] = useDescendantsInit();
  let _id = useId(id2);
  let dropdownId = id2 || makeId("menu", _id);
  let triggerId = makeId("menu-button", dropdownId);
  let [state, dispatch] = React7.useReducer(reducer, {
    ...initialState,
    triggerId
  });
  let triggerClickedRef = React7.useRef(false);
  let selectCallbacks = React7.useRef([]);
  let readyToSelect = React7.useRef(false);
  let mouseDownStartPosRef = React7.useRef({ x: 0, y: 0 });
  React7.useEffect(() => {
    if (state.isExpanded) {
      window.__REACH_DISABLE_TOOLTIPS = true;
      window.requestAnimationFrame(() => {
        focus(dropdownRef.current);
      });
    } else {
      window.__REACH_DISABLE_TOOLTIPS = false;
    }
  }, [state.isExpanded]);
  return React7.createElement(DescendantProvider, {
    context: DropdownDescendantContext,
    items: descendants,
    set: setDescendants
  }, React7.createElement(DropdownProvider, {
    dispatch,
    dropdownId,
    dropdownRef,
    mouseDownStartPosRef,
    popoverRef,
    readyToSelect,
    selectCallbacks,
    state,
    triggerClickedRef,
    triggerRef
  }, isFunction(children) ? children({
    isExpanded: state.isExpanded,
    isOpen: state.isExpanded
  }) : children));
};
DropdownProvider_.displayName = "DropdownProvider";
function useDropdownTrigger({
  onKeyDown,
  onMouseDown,
  id: id2,
  ref: forwardedRef,
  ...props2
}) {
  let {
    dispatch,
    dropdownId,
    mouseDownStartPosRef,
    triggerClickedRef,
    triggerRef,
    state: { triggerId, isExpanded }
  } = useDropdownContext("useDropdownTrigger");
  let ref = useComposedRefs(triggerRef, forwardedRef);
  let items = useDropdownDescendants();
  let firstNonDisabledIndex = React7.useMemo(() => items.findIndex((item) => !item.disabled), [items]);
  React7.useEffect(() => {
    if (id2 != null && id2 !== triggerId) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: id2
      });
    }
  }, [triggerId, dispatch, id2]);
  React7.useEffect(() => {
    if (id2 == null) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: makeId("menu-button", dropdownId)
      });
    }
  }, [dropdownId, dispatch, id2]);
  function handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault();
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: { index: firstNonDisabledIndex }
        });
        break;
      case "Enter":
      case " ":
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: { index: firstNonDisabledIndex }
        });
        break;
      default:
        break;
    }
  }
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    mouseDownStartPosRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    if (!isExpanded) {
      triggerClickedRef.current = true;
    }
    if (isExpanded) {
      dispatch({ type: CLOSE_MENU });
    } else {
      dispatch({ type: OPEN_MENU_CLEARED });
    }
  }
  return {
    data: {
      isExpanded,
      controls: dropdownId
    },
    props: {
      ...props2,
      ref,
      id: triggerId || void 0,
      onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
      onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
      type: "button"
    }
  };
}
var DropdownTrigger = React7.forwardRef(({ as: Comp = "button", ...rest }, forwardedRef) => {
  let { props: props2 } = useDropdownTrigger({ ...rest, ref: forwardedRef });
  return React7.createElement(Comp, {
    "data-reach-dropdown-trigger": "",
    ...props2
  });
});
DropdownTrigger.displayName = "DropdownTrigger";
function useDropdownItem({
  index: indexProp,
  isLink = false,
  onClick,
  onDragStart,
  onMouseDown,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseUp,
  onSelect,
  disabled,
  onFocus,
  valueText: valueTextProp,
  ref: forwardedRef,
  ...props2
}) {
  let {
    dispatch,
    dropdownRef,
    mouseDownStartPosRef,
    readyToSelect,
    selectCallbacks,
    triggerRef,
    state: { selectionIndex, isExpanded }
  } = useDropdownContext("useDropdownItem");
  let ownRef = React7.useRef(null);
  let [valueText, setValueText] = React7.useState(valueTextProp || "");
  let setValueTextFromDOM = React7.useCallback((node) => {
    if (!valueTextProp && (node == null ? void 0 : node.textContent)) {
      setValueText(node.textContent);
    }
  }, [valueTextProp]);
  let mouseEventStarted = React7.useRef(false);
  let [element, handleRefSet] = useStatefulRefValue(ownRef, null);
  let descendant = React7.useMemo(() => {
    return {
      element,
      key: valueText,
      disabled,
      isLink
    };
  }, [disabled, element, isLink, valueText]);
  let index = useDescendant(descendant, DropdownDescendantContext, indexProp);
  let isSelected = index === selectionIndex && !disabled;
  let ref = useComposedRefs(forwardedRef, handleRefSet, setValueTextFromDOM);
  selectCallbacks.current[index] = onSelect;
  function select() {
    focus(triggerRef.current);
    onSelect && onSelect();
    dispatch({ type: CLICK_MENU_ITEM });
  }
  function handleClick(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      if (disabled) {
        event.preventDefault();
      } else {
        select();
      }
    }
  }
  function handleDragStart(event) {
    if (isLink) {
      event.preventDefault();
    }
  }
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      mouseEventStarted.current = true;
    } else {
      event.preventDefault();
    }
  }
  function handleMouseEnter(event) {
    let doc = getOwnerDocument(dropdownRef.current);
    if (!isSelected && index != null && !disabled) {
      if ((dropdownRef == null ? void 0 : dropdownRef.current) && dropdownRef.current !== doc.activeElement && ownRef.current !== doc.activeElement) {
        dropdownRef.current.focus();
      }
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseLeave(event) {
    dispatch({ type: CLEAR_SELECTION_INDEX });
  }
  function handleMouseMove(event) {
    if (!readyToSelect.current) {
      let threshold = 8;
      let deltaX = Math.abs(event.clientX - mouseDownStartPosRef.current.x);
      let deltaY = Math.abs(event.clientY - mouseDownStartPosRef.current.y);
      if (deltaX > threshold || deltaY > threshold) {
        readyToSelect.current = true;
      }
    }
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    }
  }
  function handleFocus() {
    readyToSelect.current = true;
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseUp(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (!readyToSelect.current) {
      readyToSelect.current = true;
      return;
    }
    if (isLink) {
      if (mouseEventStarted.current) {
        mouseEventStarted.current = false;
      } else if (ownRef.current) {
        ownRef.current.click();
      }
    } else {
      if (!disabled) {
        select();
      }
    }
  }
  React7.useEffect(() => {
    if (isExpanded) {
      let id2 = window.setTimeout(() => {
        readyToSelect.current = true;
      }, 400);
      return () => {
        window.clearTimeout(id2);
      };
    } else {
      readyToSelect.current = false;
    }
  }, [isExpanded, readyToSelect]);
  React7.useEffect(() => {
    let ownerDocument = getOwnerDocument(ownRef.current);
    ownerDocument.addEventListener("mouseup", listener);
    return () => {
      ownerDocument.removeEventListener("mouseup", listener);
    };
    function listener() {
      mouseEventStarted.current = false;
    }
  }, []);
  return {
    data: {
      disabled
    },
    props: {
      id: useItemId(index),
      tabIndex: -1,
      ...props2,
      ref,
      "data-disabled": disabled ? "" : void 0,
      "data-selected": isSelected ? "" : void 0,
      "data-valuetext": valueText,
      onClick: composeEventHandlers(onClick, handleClick),
      onDragStart: composeEventHandlers(onDragStart, handleDragStart),
      onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
      onMouseEnter: composeEventHandlers(onMouseEnter, handleMouseEnter),
      onMouseLeave: composeEventHandlers(onMouseLeave, handleMouseLeave),
      onMouseMove: composeEventHandlers(onMouseMove, handleMouseMove),
      onFocus: composeEventHandlers(onFocus, handleFocus),
      onMouseUp: composeEventHandlers(onMouseUp, handleMouseUp)
    }
  };
}
var DropdownItem = React7.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let { props: props2 } = useDropdownItem({ ...rest, ref: forwardedRef });
  return React7.createElement(Comp, {
    "data-reach-dropdown-item": "",
    ...props2
  });
});
DropdownItem.displayName = "DropdownItem";
function useDropdownItems({
  id: id2,
  onKeyDown,
  ref: forwardedRef,
  ...props2
}) {
  let {
    dispatch,
    triggerRef,
    dropdownRef,
    selectCallbacks,
    dropdownId,
    state: { isExpanded, triggerId, selectionIndex, typeaheadQuery }
  } = useDropdownContext("useDropdownItems");
  let items = useDropdownDescendants();
  let ref = useComposedRefs(dropdownRef, forwardedRef);
  React7.useEffect(() => {
    let match = findItemFromTypeahead(items, typeaheadQuery);
    if (typeaheadQuery && match != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: match,
          dropdownRef
        }
      });
    }
    let timeout = window.setTimeout(() => typeaheadQuery && dispatch({ type: SEARCH_FOR_ITEM, payload: "" }), 1e3);
    return () => window.clearTimeout(timeout);
  }, [dispatch, items, typeaheadQuery, dropdownRef]);
  let prevItemsLength = usePrevious(items.length);
  let prevSelected = usePrevious(items[selectionIndex]);
  let prevSelectionIndex = usePrevious(selectionIndex);
  React7.useEffect(() => {
    if (selectionIndex > items.length - 1) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.length - 1,
          dropdownRef
        }
      });
    } else if (prevItemsLength !== items.length && selectionIndex > -1 && prevSelected && prevSelectionIndex === selectionIndex && items[selectionIndex] !== prevSelected) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.findIndex((i) => i.key === (prevSelected == null ? void 0 : prevSelected.key)),
          dropdownRef
        }
      });
    }
  }, [
    dropdownRef,
    dispatch,
    items,
    prevItemsLength,
    prevSelected,
    prevSelectionIndex,
    selectionIndex
  ]);
  let handleKeyDown = composeEventHandlers(function handleKeyDown2(event) {
    let { key } = event;
    if (!isExpanded) {
      return;
    }
    switch (key) {
      case "Enter":
      case " ":
        let selected = items.find((item) => item.index === selectionIndex);
        if (selected && !selected.disabled) {
          event.preventDefault();
          if (selected.isLink && selected.element) {
            selected.element.click();
          } else {
            focus(triggerRef.current);
            selectCallbacks.current[selected.index] && selectCallbacks.current[selected.index]();
            dispatch({ type: CLICK_MENU_ITEM });
          }
        }
        break;
      case "Escape":
        focus(triggerRef.current);
        dispatch({ type: CLOSE_MENU });
        break;
      case "Tab":
        event.preventDefault();
        break;
      default:
        if (isString(key) && key.length === 1) {
          let query = typeaheadQuery + key.toLowerCase();
          dispatch({
            type: SEARCH_FOR_ITEM,
            payload: query
          });
        }
        break;
    }
  }, useDescendantKeyDown(DropdownDescendantContext, {
    currentIndex: selectionIndex,
    orientation: "vertical",
    rotate: false,
    filter: (item) => !item.disabled,
    callback: (index) => {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    },
    key: "index"
  }));
  return {
    data: {
      activeDescendant: useItemId(selectionIndex) || void 0,
      triggerId
    },
    props: {
      tabIndex: -1,
      ...props2,
      ref,
      id: dropdownId,
      onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
    }
  };
}
var DropdownItems = React7.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let { props: props2 } = useDropdownItems({ ...rest, ref: forwardedRef });
  return React7.createElement(Comp, {
    "data-reach-dropdown-items": "",
    ...props2
  });
});
DropdownItems.displayName = "DropdownItems";
function useDropdownPopover({
  onBlur,
  portal = true,
  position,
  ref: forwardedRef,
  ...props2
}) {
  let {
    triggerRef,
    triggerClickedRef,
    dispatch,
    dropdownRef,
    popoverRef,
    state: { isExpanded }
  } = useDropdownContext("useDropdownPopover");
  let ref = useComposedRefs(popoverRef, forwardedRef);
  React7.useEffect(() => {
    if (!isExpanded) {
      return;
    }
    let ownerDocument = getOwnerDocument(popoverRef.current);
    function listener(event) {
      if (triggerClickedRef.current) {
        triggerClickedRef.current = false;
      } else if (!popoverContainsEventTarget(popoverRef.current, event.target)) {
        dispatch({ type: CLOSE_MENU });
      }
    }
    ownerDocument.addEventListener("mousedown", listener);
    return () => {
      ownerDocument.removeEventListener("mousedown", listener);
    };
  }, [
    triggerClickedRef,
    triggerRef,
    dispatch,
    dropdownRef,
    popoverRef,
    isExpanded
  ]);
  return {
    data: {
      portal,
      position,
      targetRef: triggerRef,
      isExpanded
    },
    props: {
      ref,
      hidden: !isExpanded,
      onBlur: composeEventHandlers(onBlur, (event) => {
        if (event.currentTarget.contains(event.relatedTarget)) {
          return;
        }
        dispatch({ type: CLOSE_MENU });
      }),
      ...props2
    }
  };
}
var DropdownPopover = React7.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let {
    data: { portal, targetRef, position },
    props: props2
  } = useDropdownPopover({ ...rest, ref: forwardedRef });
  let sharedProps = {
    "data-reach-dropdown-popover": ""
  };
  return portal ? React7.createElement(Popover, {
    ...props2,
    ...sharedProps,
    as: Comp,
    targetRef,
    position,
    unstable_skipInitialPortalRender: true
  }) : React7.createElement(Comp, {
    ...props2,
    ...sharedProps
  });
});
DropdownPopover.displayName = "DropdownPopover";
function findItemFromTypeahead(items, string = "") {
  if (!string) {
    return null;
  }
  let found = items.find((item) => {
    var _a, _b, _c;
    return item.disabled ? false : (_c = (_b = (_a = item.element) == null ? void 0 : _a.dataset) == null ? void 0 : _b.valuetext) == null ? void 0 : _c.toLowerCase().startsWith(string);
  });
  return found ? items.indexOf(found) : null;
}
function useItemId(index) {
  let { dropdownId } = useDropdownContext("useItemId");
  return index != null && index > -1 ? makeId(`option-${index}`, dropdownId) : void 0;
}
function focus(element) {
  element && element.focus();
}
function popoverContainsEventTarget(popover, target) {
  return !!(popover && popover.contains(target));
}
function reducer(state, action = {}) {
  switch (action.type) {
    case CLICK_MENU_ITEM:
      return {
        ...state,
        isExpanded: false,
        selectionIndex: -1
      };
    case CLOSE_MENU:
      return {
        ...state,
        isExpanded: false,
        selectionIndex: -1
      };
    case OPEN_MENU_AT_FIRST_ITEM:
      return {
        ...state,
        isExpanded: true,
        selectionIndex: 0
      };
    case OPEN_MENU_AT_INDEX:
      return {
        ...state,
        isExpanded: true,
        selectionIndex: action.payload.index
      };
    case OPEN_MENU_CLEARED:
      return {
        ...state,
        isExpanded: true,
        selectionIndex: -1
      };
    case SELECT_ITEM_AT_INDEX: {
      let { dropdownRef = { current: null } } = action.payload;
      if (action.payload.index >= 0 && action.payload.index !== state.selectionIndex) {
        if (dropdownRef.current) {
          let doc = getOwnerDocument(dropdownRef.current);
          if (dropdownRef.current !== (doc == null ? void 0 : doc.activeElement)) {
            dropdownRef.current.focus();
          }
        }
        return {
          ...state,
          selectionIndex: action.payload.max != null ? Math.min(Math.max(action.payload.index, 0), action.payload.max) : Math.max(action.payload.index, 0)
        };
      }
      return state;
    }
    case CLEAR_SELECTION_INDEX:
      return {
        ...state,
        selectionIndex: -1
      };
    case SET_BUTTON_ID:
      return {
        ...state,
        triggerId: action.payload
      };
    case SEARCH_FOR_ITEM:
      if (typeof action.payload !== "undefined") {
        return {
          ...state,
          typeaheadQuery: action.payload
        };
      }
      return state;
    default:
      return state;
  }
}
function useDropdownDescendants() {
  return useDescendants(DropdownDescendantContext);
}

// node_modules/@reach/menu-button/dist/reach-menu-button.mjs
var import_react_is = __toESM(require_react_is(), 1);
var Menu = React8.forwardRef(({ as: Comp = React8.Fragment, id: id2, children, ...rest }, forwardedRef) => {
  let parentIsFragment = React8.useMemo(() => {
    try {
      return (0, import_react_is.isFragment)(React8.createElement(Comp, null));
    } catch (err) {
      return false;
    }
  }, [Comp]);
  let props2 = parentIsFragment ? {} : {
    ref: forwardedRef,
    id: id2,
    "data-reach-menu": "",
    ...rest
  };
  return React8.createElement(Comp, {
    ...props2
  }, React8.createElement(DropdownProvider_, {
    id: id2,
    children
  }));
});
Menu.displayName = "Menu";
var MenuButton = React8.forwardRef(({ as: Comp = "button", ...rest }, forwardedRef) => {
  let {
    data: { isExpanded, controls },
    props: props2
  } = useDropdownTrigger({ ...rest, ref: forwardedRef });
  return React8.createElement(Comp, {
    "aria-expanded": isExpanded ? true : void 0,
    "aria-haspopup": true,
    "aria-controls": controls,
    ...props2,
    "data-reach-menu-button": ""
  });
});
MenuButton.displayName = "MenuButton";
var MenuItemImpl = React8.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let {
    data: { disabled },
    props: props2
  } = useDropdownItem({ ...rest, ref: forwardedRef });
  return React8.createElement(Comp, {
    role: "menuitem",
    ...props2,
    "aria-disabled": disabled || void 0,
    "data-reach-menu-item": ""
  });
});
MenuItemImpl.displayName = "MenuItemImpl";
var MenuItem = React8.forwardRef(({ as = "div", ...props2 }, forwardedRef) => {
  return React8.createElement(MenuItemImpl, {
    ...props2,
    ref: forwardedRef,
    as
  });
});
MenuItem.displayName = "MenuItem";
var MenuItems = React8.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let {
    data: { activeDescendant, triggerId },
    props: props2
  } = useDropdownItems({ ...rest, ref: forwardedRef });
  return React8.createElement(Comp, {
    "aria-activedescendant": activeDescendant,
    "aria-labelledby": triggerId || void 0,
    role: "menu",
    ...props2,
    "data-reach-menu-items": ""
  });
});
MenuItems.displayName = "MenuItems";
var MenuLink = React8.forwardRef(({
  as = "a",
  component,
  onSelect,
  ...props2
}, forwardedRef) => {
  if (true) {
    React8.useEffect(() => {
      if (component) {
        console.warn("[@reach/menu-button]: Please use the `as` prop instead of `component`");
      }
    }, [component]);
  }
  return React8.createElement(MenuItemImpl, {
    ...props2,
    ref: forwardedRef,
    "data-reach-menu-link": "",
    as,
    isLink: true,
    onSelect: onSelect || noop
  });
});
MenuLink.displayName = "MenuLink";
var MenuList = React8.forwardRef(({ portal = true, ...props2 }, forwardedRef) => {
  return React8.createElement(MenuPopover, {
    portal
  }, React8.createElement(MenuItems, {
    ...props2,
    ref: forwardedRef,
    "data-reach-menu-list": ""
  }));
});
MenuList.displayName = "MenuList";
var MenuPopover = React8.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let {
    data: { portal, targetRef, position },
    props: props2
  } = useDropdownPopover({ ...rest, ref: forwardedRef });
  let sharedProps = {
    "data-reach-menu-popover": ""
  };
  return portal ? React8.createElement(Popover, {
    ...props2,
    ...sharedProps,
    as: Comp,
    targetRef,
    position,
    unstable_skipInitialPortalRender: true
  }) : React8.createElement(Comp, {
    ...props2,
    ...sharedProps
  });
});
MenuPopover.displayName = "MenuPopover";
function useMenuButtonContext() {
  let {
    state: { isExpanded }
  } = useDropdownContext("useMenuButtonContext");
  return React8.useMemo(() => ({ isExpanded }), [isExpanded]);
}
export {
  Menu,
  MenuButton,
  MenuItem,
  MenuItems,
  MenuLink,
  MenuList,
  MenuPopover,
  useMenuButtonContext
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@reach/utils/dist/reach-utils.mjs:
  (**
    * @reach/utils v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/portal/dist/reach-portal.mjs:
  (**
    * @reach/portal v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/rect/dist/reach-rect.mjs:
  (**
    * @reach/rect v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

@reach/popover/dist/reach-popover.mjs:
  (**
    * @reach/popover v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/auto-id/dist/reach-auto-id.mjs:
  (**
    * @reach/auto-id v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/descendants/dist/reach-descendants.mjs:
  (**
    * @reach/descendants v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/dropdown/dist/reach-dropdown.mjs:
  (**
    * @reach/dropdown v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/menu-button/dist/reach-menu-button.mjs:
  (**
    * @reach/menu-button v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)
*/
//# sourceMappingURL=@reach_menu-button.js.map
