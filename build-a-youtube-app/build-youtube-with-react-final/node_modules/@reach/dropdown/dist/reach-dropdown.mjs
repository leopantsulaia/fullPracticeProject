"use strict";
/**
  * @reach/dropdown v0.18.0
  *
  * Copyright (c) 2018-2022, React Training LLC
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */


// src/reach-dropdown.tsx
import * as React from "react";
import { useId } from "@reach/auto-id";
import { Popover } from "@reach/popover";
import {
  createDescendantContext,
  DescendantProvider,
  useDescendant,
  useDescendants,
  useDescendantsInit,
  useDescendantKeyDown
} from "@reach/descendants";
import {
  composeEventHandlers,
  createContext,
  getOwnerDocument,
  isFunction,
  isString,
  isRightClick,
  useComposedRefs,
  usePrevious,
  useStatefulRefValue,
  makeId
} from "@reach/utils";
var CLEAR_SELECTION_INDEX = "CLEAR_SELECTION_INDEX";
var CLICK_MENU_ITEM = "CLICK_MENU_ITEM";
var CLOSE_MENU = "CLOSE_MENU";
var OPEN_MENU_AT_FIRST_ITEM = "OPEN_MENU_AT_FIRST_ITEM";
var OPEN_MENU_AT_INDEX = "OPEN_MENU_AT_INDEX";
var OPEN_MENU_CLEARED = "OPEN_MENU_CLEARED";
var SEARCH_FOR_ITEM = "SEARCH_FOR_ITEM";
var SELECT_ITEM_AT_INDEX = "SELECT_ITEM_AT_INDEX";
var SET_BUTTON_ID = "SET_BUTTON_ID";
var DropdownDescendantContext = createDescendantContext("DropdownDescendantContext");
var [DropdownProvider, useDropdownContext] = createContext("Dropdown");
var initialState = {
  triggerId: null,
  isExpanded: false,
  typeaheadQuery: "",
  selectionIndex: -1
};
var DropdownProvider_ = ({
  id,
  children
}) => {
  let triggerRef = React.useRef(null);
  let dropdownRef = React.useRef(null);
  let popoverRef = React.useRef(null);
  let [descendants, setDescendants] = useDescendantsInit();
  let _id = useId(id);
  let dropdownId = id || makeId("menu", _id);
  let triggerId = makeId("menu-button", dropdownId);
  let [state, dispatch] = React.useReducer(reducer, {
    ...initialState,
    triggerId
  });
  let triggerClickedRef = React.useRef(false);
  let selectCallbacks = React.useRef([]);
  let readyToSelect = React.useRef(false);
  let mouseDownStartPosRef = React.useRef({ x: 0, y: 0 });
  React.useEffect(() => {
    if (state.isExpanded) {
      window.__REACH_DISABLE_TOOLTIPS = true;
      window.requestAnimationFrame(() => {
        focus(dropdownRef.current);
      });
    } else {
      window.__REACH_DISABLE_TOOLTIPS = false;
    }
  }, [state.isExpanded]);
  return /* @__PURE__ */ React.createElement(DescendantProvider, {
    context: DropdownDescendantContext,
    items: descendants,
    set: setDescendants
  }, /* @__PURE__ */ React.createElement(DropdownProvider, {
    dispatch,
    dropdownId,
    dropdownRef,
    mouseDownStartPosRef,
    popoverRef,
    readyToSelect,
    selectCallbacks,
    state,
    triggerClickedRef,
    triggerRef
  }, isFunction(children) ? children({
    isExpanded: state.isExpanded,
    isOpen: state.isExpanded
  }) : children));
};
DropdownProvider_.displayName = "DropdownProvider";
function useDropdownTrigger({
  onKeyDown,
  onMouseDown,
  id,
  ref: forwardedRef,
  ...props
}) {
  let {
    dispatch,
    dropdownId,
    mouseDownStartPosRef,
    triggerClickedRef,
    triggerRef,
    state: { triggerId, isExpanded }
  } = useDropdownContext("useDropdownTrigger");
  let ref = useComposedRefs(triggerRef, forwardedRef);
  let items = useDropdownDescendants();
  let firstNonDisabledIndex = React.useMemo(() => items.findIndex((item) => !item.disabled), [items]);
  React.useEffect(() => {
    if (id != null && id !== triggerId) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: id
      });
    }
  }, [triggerId, dispatch, id]);
  React.useEffect(() => {
    if (id == null) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: makeId("menu-button", dropdownId)
      });
    }
  }, [dropdownId, dispatch, id]);
  function handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault();
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: { index: firstNonDisabledIndex }
        });
        break;
      case "Enter":
      case " ":
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: { index: firstNonDisabledIndex }
        });
        break;
      default:
        break;
    }
  }
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    mouseDownStartPosRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    if (!isExpanded) {
      triggerClickedRef.current = true;
    }
    if (isExpanded) {
      dispatch({ type: CLOSE_MENU });
    } else {
      dispatch({ type: OPEN_MENU_CLEARED });
    }
  }
  return {
    data: {
      isExpanded,
      controls: dropdownId
    },
    props: {
      ...props,
      ref,
      id: triggerId || void 0,
      onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
      onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
      type: "button"
    }
  };
}
var DropdownTrigger = React.forwardRef(({ as: Comp = "button", ...rest }, forwardedRef) => {
  let { props } = useDropdownTrigger({ ...rest, ref: forwardedRef });
  return /* @__PURE__ */ React.createElement(Comp, {
    "data-reach-dropdown-trigger": "",
    ...props
  });
});
DropdownTrigger.displayName = "DropdownTrigger";
function useDropdownItem({
  index: indexProp,
  isLink = false,
  onClick,
  onDragStart,
  onMouseDown,
  onMouseEnter,
  onMouseLeave,
  onMouseMove,
  onMouseUp,
  onSelect,
  disabled,
  onFocus,
  valueText: valueTextProp,
  ref: forwardedRef,
  ...props
}) {
  let {
    dispatch,
    dropdownRef,
    mouseDownStartPosRef,
    readyToSelect,
    selectCallbacks,
    triggerRef,
    state: { selectionIndex, isExpanded }
  } = useDropdownContext("useDropdownItem");
  let ownRef = React.useRef(null);
  let [valueText, setValueText] = React.useState(valueTextProp || "");
  let setValueTextFromDOM = React.useCallback((node) => {
    if (!valueTextProp && node?.textContent) {
      setValueText(node.textContent);
    }
  }, [valueTextProp]);
  let mouseEventStarted = React.useRef(false);
  let [element, handleRefSet] = useStatefulRefValue(ownRef, null);
  let descendant = React.useMemo(() => {
    return {
      element,
      key: valueText,
      disabled,
      isLink
    };
  }, [disabled, element, isLink, valueText]);
  let index = useDescendant(descendant, DropdownDescendantContext, indexProp);
  let isSelected = index === selectionIndex && !disabled;
  let ref = useComposedRefs(forwardedRef, handleRefSet, setValueTextFromDOM);
  selectCallbacks.current[index] = onSelect;
  function select() {
    focus(triggerRef.current);
    onSelect && onSelect();
    dispatch({ type: CLICK_MENU_ITEM });
  }
  function handleClick(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      if (disabled) {
        event.preventDefault();
      } else {
        select();
      }
    }
  }
  function handleDragStart(event) {
    if (isLink) {
      event.preventDefault();
    }
  }
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      mouseEventStarted.current = true;
    } else {
      event.preventDefault();
    }
  }
  function handleMouseEnter(event) {
    let doc = getOwnerDocument(dropdownRef.current);
    if (!isSelected && index != null && !disabled) {
      if (dropdownRef?.current && dropdownRef.current !== doc.activeElement && ownRef.current !== doc.activeElement) {
        dropdownRef.current.focus();
      }
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseLeave(event) {
    dispatch({ type: CLEAR_SELECTION_INDEX });
  }
  function handleMouseMove(event) {
    if (!readyToSelect.current) {
      let threshold = 8;
      let deltaX = Math.abs(event.clientX - mouseDownStartPosRef.current.x);
      let deltaY = Math.abs(event.clientY - mouseDownStartPosRef.current.y);
      if (deltaX > threshold || deltaY > threshold) {
        readyToSelect.current = true;
      }
    }
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    }
  }
  function handleFocus() {
    readyToSelect.current = true;
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseUp(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (!readyToSelect.current) {
      readyToSelect.current = true;
      return;
    }
    if (isLink) {
      if (mouseEventStarted.current) {
        mouseEventStarted.current = false;
      } else if (ownRef.current) {
        ownRef.current.click();
      }
    } else {
      if (!disabled) {
        select();
      }
    }
  }
  React.useEffect(() => {
    if (isExpanded) {
      let id = window.setTimeout(() => {
        readyToSelect.current = true;
      }, 400);
      return () => {
        window.clearTimeout(id);
      };
    } else {
      readyToSelect.current = false;
    }
  }, [isExpanded, readyToSelect]);
  React.useEffect(() => {
    let ownerDocument = getOwnerDocument(ownRef.current);
    ownerDocument.addEventListener("mouseup", listener);
    return () => {
      ownerDocument.removeEventListener("mouseup", listener);
    };
    function listener() {
      mouseEventStarted.current = false;
    }
  }, []);
  return {
    data: {
      disabled
    },
    props: {
      id: useItemId(index),
      tabIndex: -1,
      ...props,
      ref,
      "data-disabled": disabled ? "" : void 0,
      "data-selected": isSelected ? "" : void 0,
      "data-valuetext": valueText,
      onClick: composeEventHandlers(onClick, handleClick),
      onDragStart: composeEventHandlers(onDragStart, handleDragStart),
      onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
      onMouseEnter: composeEventHandlers(onMouseEnter, handleMouseEnter),
      onMouseLeave: composeEventHandlers(onMouseLeave, handleMouseLeave),
      onMouseMove: composeEventHandlers(onMouseMove, handleMouseMove),
      onFocus: composeEventHandlers(onFocus, handleFocus),
      onMouseUp: composeEventHandlers(onMouseUp, handleMouseUp)
    }
  };
}
var DropdownItem = React.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let { props } = useDropdownItem({ ...rest, ref: forwardedRef });
  return /* @__PURE__ */ React.createElement(Comp, {
    "data-reach-dropdown-item": "",
    ...props
  });
});
DropdownItem.displayName = "DropdownItem";
function useDropdownItems({
  id,
  onKeyDown,
  ref: forwardedRef,
  ...props
}) {
  let {
    dispatch,
    triggerRef,
    dropdownRef,
    selectCallbacks,
    dropdownId,
    state: { isExpanded, triggerId, selectionIndex, typeaheadQuery }
  } = useDropdownContext("useDropdownItems");
  let items = useDropdownDescendants();
  let ref = useComposedRefs(dropdownRef, forwardedRef);
  React.useEffect(() => {
    let match = findItemFromTypeahead(items, typeaheadQuery);
    if (typeaheadQuery && match != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: match,
          dropdownRef
        }
      });
    }
    let timeout = window.setTimeout(() => typeaheadQuery && dispatch({ type: SEARCH_FOR_ITEM, payload: "" }), 1e3);
    return () => window.clearTimeout(timeout);
  }, [dispatch, items, typeaheadQuery, dropdownRef]);
  let prevItemsLength = usePrevious(items.length);
  let prevSelected = usePrevious(items[selectionIndex]);
  let prevSelectionIndex = usePrevious(selectionIndex);
  React.useEffect(() => {
    if (selectionIndex > items.length - 1) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.length - 1,
          dropdownRef
        }
      });
    } else if (prevItemsLength !== items.length && selectionIndex > -1 && prevSelected && prevSelectionIndex === selectionIndex && items[selectionIndex] !== prevSelected) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.findIndex((i) => i.key === prevSelected?.key),
          dropdownRef
        }
      });
    }
  }, [
    dropdownRef,
    dispatch,
    items,
    prevItemsLength,
    prevSelected,
    prevSelectionIndex,
    selectionIndex
  ]);
  let handleKeyDown = composeEventHandlers(function handleKeyDown2(event) {
    let { key } = event;
    if (!isExpanded) {
      return;
    }
    switch (key) {
      case "Enter":
      case " ":
        let selected = items.find((item) => item.index === selectionIndex);
        if (selected && !selected.disabled) {
          event.preventDefault();
          if (selected.isLink && selected.element) {
            selected.element.click();
          } else {
            focus(triggerRef.current);
            selectCallbacks.current[selected.index] && selectCallbacks.current[selected.index]();
            dispatch({ type: CLICK_MENU_ITEM });
          }
        }
        break;
      case "Escape":
        focus(triggerRef.current);
        dispatch({ type: CLOSE_MENU });
        break;
      case "Tab":
        event.preventDefault();
        break;
      default:
        if (isString(key) && key.length === 1) {
          let query = typeaheadQuery + key.toLowerCase();
          dispatch({
            type: SEARCH_FOR_ITEM,
            payload: query
          });
        }
        break;
    }
  }, useDescendantKeyDown(DropdownDescendantContext, {
    currentIndex: selectionIndex,
    orientation: "vertical",
    rotate: false,
    filter: (item) => !item.disabled,
    callback: (index) => {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    },
    key: "index"
  }));
  return {
    data: {
      activeDescendant: useItemId(selectionIndex) || void 0,
      triggerId
    },
    props: {
      tabIndex: -1,
      ...props,
      ref,
      id: dropdownId,
      onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
    }
  };
}
var DropdownItems = React.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let { props } = useDropdownItems({ ...rest, ref: forwardedRef });
  return /* @__PURE__ */ React.createElement(Comp, {
    "data-reach-dropdown-items": "",
    ...props
  });
});
DropdownItems.displayName = "DropdownItems";
function useDropdownPopover({
  onBlur,
  portal = true,
  position,
  ref: forwardedRef,
  ...props
}) {
  let {
    triggerRef,
    triggerClickedRef,
    dispatch,
    dropdownRef,
    popoverRef,
    state: { isExpanded }
  } = useDropdownContext("useDropdownPopover");
  let ref = useComposedRefs(popoverRef, forwardedRef);
  React.useEffect(() => {
    if (!isExpanded) {
      return;
    }
    let ownerDocument = getOwnerDocument(popoverRef.current);
    function listener(event) {
      if (triggerClickedRef.current) {
        triggerClickedRef.current = false;
      } else if (!popoverContainsEventTarget(popoverRef.current, event.target)) {
        dispatch({ type: CLOSE_MENU });
      }
    }
    ownerDocument.addEventListener("mousedown", listener);
    return () => {
      ownerDocument.removeEventListener("mousedown", listener);
    };
  }, [
    triggerClickedRef,
    triggerRef,
    dispatch,
    dropdownRef,
    popoverRef,
    isExpanded
  ]);
  return {
    data: {
      portal,
      position,
      targetRef: triggerRef,
      isExpanded
    },
    props: {
      ref,
      hidden: !isExpanded,
      onBlur: composeEventHandlers(onBlur, (event) => {
        if (event.currentTarget.contains(event.relatedTarget)) {
          return;
        }
        dispatch({ type: CLOSE_MENU });
      }),
      ...props
    }
  };
}
var DropdownPopover = React.forwardRef(({ as: Comp = "div", ...rest }, forwardedRef) => {
  let {
    data: { portal, targetRef, position },
    props
  } = useDropdownPopover({ ...rest, ref: forwardedRef });
  let sharedProps = {
    "data-reach-dropdown-popover": ""
  };
  return portal ? /* @__PURE__ */ React.createElement(Popover, {
    ...props,
    ...sharedProps,
    as: Comp,
    targetRef,
    position,
    unstable_skipInitialPortalRender: true
  }) : /* @__PURE__ */ React.createElement(Comp, {
    ...props,
    ...sharedProps
  });
});
DropdownPopover.displayName = "DropdownPopover";
function findItemFromTypeahead(items, string = "") {
  if (!string) {
    return null;
  }
  let found = items.find((item) => {
    return item.disabled ? false : item.element?.dataset?.valuetext?.toLowerCase().startsWith(string);
  });
  return found ? items.indexOf(found) : null;
}
function useItemId(index) {
  let { dropdownId } = useDropdownContext("useItemId");
  return index != null && index > -1 ? makeId(`option-${index}`, dropdownId) : void 0;
}
function focus(element) {
  element && element.focus();
}
function popoverContainsEventTarget(popover, target) {
  return !!(popover && popover.contains(target));
}
function reducer(state, action = {}) {
  switch (action.type) {
    case CLICK_MENU_ITEM:
      return {
        ...state,
        isExpanded: false,
        selectionIndex: -1
      };
    case CLOSE_MENU:
      return {
        ...state,
        isExpanded: false,
        selectionIndex: -1
      };
    case OPEN_MENU_AT_FIRST_ITEM:
      return {
        ...state,
        isExpanded: true,
        selectionIndex: 0
      };
    case OPEN_MENU_AT_INDEX:
      return {
        ...state,
        isExpanded: true,
        selectionIndex: action.payload.index
      };
    case OPEN_MENU_CLEARED:
      return {
        ...state,
        isExpanded: true,
        selectionIndex: -1
      };
    case SELECT_ITEM_AT_INDEX: {
      let { dropdownRef = { current: null } } = action.payload;
      if (action.payload.index >= 0 && action.payload.index !== state.selectionIndex) {
        if (dropdownRef.current) {
          let doc = getOwnerDocument(dropdownRef.current);
          if (dropdownRef.current !== doc?.activeElement) {
            dropdownRef.current.focus();
          }
        }
        return {
          ...state,
          selectionIndex: action.payload.max != null ? Math.min(Math.max(action.payload.index, 0), action.payload.max) : Math.max(action.payload.index, 0)
        };
      }
      return state;
    }
    case CLEAR_SELECTION_INDEX:
      return {
        ...state,
        selectionIndex: -1
      };
    case SET_BUTTON_ID:
      return {
        ...state,
        triggerId: action.payload
      };
    case SEARCH_FOR_ITEM:
      if (typeof action.payload !== "undefined") {
        return {
          ...state,
          typeaheadQuery: action.payload
        };
      }
      return state;
    default:
      return state;
  }
}
function useDropdownDescendants() {
  return useDescendants(DropdownDescendantContext);
}
export {
  DropdownItem,
  DropdownItems,
  DropdownPopover,
  DropdownProvider_ as DropdownProvider,
  DropdownTrigger,
  useDropdownContext,
  useDropdownDescendants,
  useDropdownItem,
  useDropdownItems,
  useDropdownPopover,
  useDropdownTrigger
};
