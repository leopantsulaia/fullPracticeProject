"use strict";
/**
  * @reach/dropdown v0.18.0
  *
  * Copyright (c) 2018-2022, React Training LLC
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/reach-dropdown.tsx
var reach_dropdown_exports = {};
__export(reach_dropdown_exports, {
  DropdownItem: () => DropdownItem,
  DropdownItems: () => DropdownItems,
  DropdownPopover: () => DropdownPopover,
  DropdownProvider: () => DropdownProvider_,
  DropdownTrigger: () => DropdownTrigger,
  useDropdownContext: () => useDropdownContext,
  useDropdownDescendants: () => useDropdownDescendants,
  useDropdownItem: () => useDropdownItem,
  useDropdownItems: () => useDropdownItems,
  useDropdownPopover: () => useDropdownPopover,
  useDropdownTrigger: () => useDropdownTrigger
});
module.exports = __toCommonJS(reach_dropdown_exports);
var React = __toESM(require("react"));
var import_auto_id = require("@reach/auto-id");
var import_popover = require("@reach/popover");
var import_descendants = require("@reach/descendants");
var import_utils = require("@reach/utils");
var CLEAR_SELECTION_INDEX = "CLEAR_SELECTION_INDEX";
var CLICK_MENU_ITEM = "CLICK_MENU_ITEM";
var CLOSE_MENU = "CLOSE_MENU";
var OPEN_MENU_AT_FIRST_ITEM = "OPEN_MENU_AT_FIRST_ITEM";
var OPEN_MENU_AT_INDEX = "OPEN_MENU_AT_INDEX";
var OPEN_MENU_CLEARED = "OPEN_MENU_CLEARED";
var SEARCH_FOR_ITEM = "SEARCH_FOR_ITEM";
var SELECT_ITEM_AT_INDEX = "SELECT_ITEM_AT_INDEX";
var SET_BUTTON_ID = "SET_BUTTON_ID";
var DropdownDescendantContext = (0, import_descendants.createDescendantContext)("DropdownDescendantContext");
var [DropdownProvider, useDropdownContext] = (0, import_utils.createContext)("Dropdown");
var initialState = {
  triggerId: null,
  isExpanded: false,
  typeaheadQuery: "",
  selectionIndex: -1
};
var DropdownProvider_ = ({
  id,
  children
}) => {
  let triggerRef = React.useRef(null);
  let dropdownRef = React.useRef(null);
  let popoverRef = React.useRef(null);
  let [descendants, setDescendants] = (0, import_descendants.useDescendantsInit)();
  let _id = (0, import_auto_id.useId)(id);
  let dropdownId = id || (0, import_utils.makeId)("menu", _id);
  let triggerId = (0, import_utils.makeId)("menu-button", dropdownId);
  let [state, dispatch] = React.useReducer(reducer, __spreadProps(__spreadValues({}, initialState), {
    triggerId
  }));
  let triggerClickedRef = React.useRef(false);
  let selectCallbacks = React.useRef([]);
  let readyToSelect = React.useRef(false);
  let mouseDownStartPosRef = React.useRef({ x: 0, y: 0 });
  React.useEffect(() => {
    if (state.isExpanded) {
      window.__REACH_DISABLE_TOOLTIPS = true;
      window.requestAnimationFrame(() => {
        focus(dropdownRef.current);
      });
    } else {
      window.__REACH_DISABLE_TOOLTIPS = false;
    }
  }, [state.isExpanded]);
  return /* @__PURE__ */ React.createElement(import_descendants.DescendantProvider, {
    context: DropdownDescendantContext,
    items: descendants,
    set: setDescendants
  }, /* @__PURE__ */ React.createElement(DropdownProvider, {
    dispatch,
    dropdownId,
    dropdownRef,
    mouseDownStartPosRef,
    popoverRef,
    readyToSelect,
    selectCallbacks,
    state,
    triggerClickedRef,
    triggerRef
  }, (0, import_utils.isFunction)(children) ? children({
    isExpanded: state.isExpanded,
    isOpen: state.isExpanded
  }) : children));
};
DropdownProvider_.displayName = "DropdownProvider";
function useDropdownTrigger(_a) {
  var _b = _a, {
    onKeyDown,
    onMouseDown,
    id,
    ref: forwardedRef
  } = _b, props = __objRest(_b, [
    "onKeyDown",
    "onMouseDown",
    "id",
    "ref"
  ]);
  let {
    dispatch,
    dropdownId,
    mouseDownStartPosRef,
    triggerClickedRef,
    triggerRef,
    state: { triggerId, isExpanded }
  } = useDropdownContext("useDropdownTrigger");
  let ref = (0, import_utils.useComposedRefs)(triggerRef, forwardedRef);
  let items = useDropdownDescendants();
  let firstNonDisabledIndex = React.useMemo(() => items.findIndex((item) => !item.disabled), [items]);
  React.useEffect(() => {
    if (id != null && id !== triggerId) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: id
      });
    }
  }, [triggerId, dispatch, id]);
  React.useEffect(() => {
    if (id == null) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: (0, import_utils.makeId)("menu-button", dropdownId)
      });
    }
  }, [dropdownId, dispatch, id]);
  function handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault();
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: { index: firstNonDisabledIndex }
        });
        break;
      case "Enter":
      case " ":
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: { index: firstNonDisabledIndex }
        });
        break;
      default:
        break;
    }
  }
  function handleMouseDown(event) {
    if ((0, import_utils.isRightClick)(event.nativeEvent)) {
      return;
    }
    mouseDownStartPosRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    if (!isExpanded) {
      triggerClickedRef.current = true;
    }
    if (isExpanded) {
      dispatch({ type: CLOSE_MENU });
    } else {
      dispatch({ type: OPEN_MENU_CLEARED });
    }
  }
  return {
    data: {
      isExpanded,
      controls: dropdownId
    },
    props: __spreadProps(__spreadValues({}, props), {
      ref,
      id: triggerId || void 0,
      onKeyDown: (0, import_utils.composeEventHandlers)(onKeyDown, handleKeyDown),
      onMouseDown: (0, import_utils.composeEventHandlers)(onMouseDown, handleMouseDown),
      type: "button"
    })
  };
}
var DropdownTrigger = React.forwardRef((_a, forwardedRef) => {
  var _b = _a, { as: Comp = "button" } = _b, rest = __objRest(_b, ["as"]);
  let { props } = useDropdownTrigger(__spreadProps(__spreadValues({}, rest), { ref: forwardedRef }));
  return /* @__PURE__ */ React.createElement(Comp, __spreadValues({
    "data-reach-dropdown-trigger": ""
  }, props));
});
DropdownTrigger.displayName = "DropdownTrigger";
function useDropdownItem(_a) {
  var _b = _a, {
    index: indexProp,
    isLink = false,
    onClick,
    onDragStart,
    onMouseDown,
    onMouseEnter,
    onMouseLeave,
    onMouseMove,
    onMouseUp,
    onSelect,
    disabled,
    onFocus,
    valueText: valueTextProp,
    ref: forwardedRef
  } = _b, props = __objRest(_b, [
    "index",
    "isLink",
    "onClick",
    "onDragStart",
    "onMouseDown",
    "onMouseEnter",
    "onMouseLeave",
    "onMouseMove",
    "onMouseUp",
    "onSelect",
    "disabled",
    "onFocus",
    "valueText",
    "ref"
  ]);
  let {
    dispatch,
    dropdownRef,
    mouseDownStartPosRef,
    readyToSelect,
    selectCallbacks,
    triggerRef,
    state: { selectionIndex, isExpanded }
  } = useDropdownContext("useDropdownItem");
  let ownRef = React.useRef(null);
  let [valueText, setValueText] = React.useState(valueTextProp || "");
  let setValueTextFromDOM = React.useCallback((node) => {
    if (!valueTextProp && (node == null ? void 0 : node.textContent)) {
      setValueText(node.textContent);
    }
  }, [valueTextProp]);
  let mouseEventStarted = React.useRef(false);
  let [element, handleRefSet] = (0, import_utils.useStatefulRefValue)(ownRef, null);
  let descendant = React.useMemo(() => {
    return {
      element,
      key: valueText,
      disabled,
      isLink
    };
  }, [disabled, element, isLink, valueText]);
  let index = (0, import_descendants.useDescendant)(descendant, DropdownDescendantContext, indexProp);
  let isSelected = index === selectionIndex && !disabled;
  let ref = (0, import_utils.useComposedRefs)(forwardedRef, handleRefSet, setValueTextFromDOM);
  selectCallbacks.current[index] = onSelect;
  function select() {
    focus(triggerRef.current);
    onSelect && onSelect();
    dispatch({ type: CLICK_MENU_ITEM });
  }
  function handleClick(event) {
    if ((0, import_utils.isRightClick)(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      if (disabled) {
        event.preventDefault();
      } else {
        select();
      }
    }
  }
  function handleDragStart(event) {
    if (isLink) {
      event.preventDefault();
    }
  }
  function handleMouseDown(event) {
    if ((0, import_utils.isRightClick)(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      mouseEventStarted.current = true;
    } else {
      event.preventDefault();
    }
  }
  function handleMouseEnter(event) {
    let doc = (0, import_utils.getOwnerDocument)(dropdownRef.current);
    if (!isSelected && index != null && !disabled) {
      if ((dropdownRef == null ? void 0 : dropdownRef.current) && dropdownRef.current !== doc.activeElement && ownRef.current !== doc.activeElement) {
        dropdownRef.current.focus();
      }
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseLeave(event) {
    dispatch({ type: CLEAR_SELECTION_INDEX });
  }
  function handleMouseMove(event) {
    if (!readyToSelect.current) {
      let threshold = 8;
      let deltaX = Math.abs(event.clientX - mouseDownStartPosRef.current.x);
      let deltaY = Math.abs(event.clientY - mouseDownStartPosRef.current.y);
      if (deltaX > threshold || deltaY > threshold) {
        readyToSelect.current = true;
      }
    }
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    }
  }
  function handleFocus() {
    readyToSelect.current = true;
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  function handleMouseUp(event) {
    if ((0, import_utils.isRightClick)(event.nativeEvent)) {
      return;
    }
    if (!readyToSelect.current) {
      readyToSelect.current = true;
      return;
    }
    if (isLink) {
      if (mouseEventStarted.current) {
        mouseEventStarted.current = false;
      } else if (ownRef.current) {
        ownRef.current.click();
      }
    } else {
      if (!disabled) {
        select();
      }
    }
  }
  React.useEffect(() => {
    if (isExpanded) {
      let id = window.setTimeout(() => {
        readyToSelect.current = true;
      }, 400);
      return () => {
        window.clearTimeout(id);
      };
    } else {
      readyToSelect.current = false;
    }
  }, [isExpanded, readyToSelect]);
  React.useEffect(() => {
    let ownerDocument = (0, import_utils.getOwnerDocument)(ownRef.current);
    ownerDocument.addEventListener("mouseup", listener);
    return () => {
      ownerDocument.removeEventListener("mouseup", listener);
    };
    function listener() {
      mouseEventStarted.current = false;
    }
  }, []);
  return {
    data: {
      disabled
    },
    props: __spreadProps(__spreadValues({
      id: useItemId(index),
      tabIndex: -1
    }, props), {
      ref,
      "data-disabled": disabled ? "" : void 0,
      "data-selected": isSelected ? "" : void 0,
      "data-valuetext": valueText,
      onClick: (0, import_utils.composeEventHandlers)(onClick, handleClick),
      onDragStart: (0, import_utils.composeEventHandlers)(onDragStart, handleDragStart),
      onMouseDown: (0, import_utils.composeEventHandlers)(onMouseDown, handleMouseDown),
      onMouseEnter: (0, import_utils.composeEventHandlers)(onMouseEnter, handleMouseEnter),
      onMouseLeave: (0, import_utils.composeEventHandlers)(onMouseLeave, handleMouseLeave),
      onMouseMove: (0, import_utils.composeEventHandlers)(onMouseMove, handleMouseMove),
      onFocus: (0, import_utils.composeEventHandlers)(onFocus, handleFocus),
      onMouseUp: (0, import_utils.composeEventHandlers)(onMouseUp, handleMouseUp)
    })
  };
}
var DropdownItem = React.forwardRef((_a, forwardedRef) => {
  var _b = _a, { as: Comp = "div" } = _b, rest = __objRest(_b, ["as"]);
  let { props } = useDropdownItem(__spreadProps(__spreadValues({}, rest), { ref: forwardedRef }));
  return /* @__PURE__ */ React.createElement(Comp, __spreadValues({
    "data-reach-dropdown-item": ""
  }, props));
});
DropdownItem.displayName = "DropdownItem";
function useDropdownItems(_a) {
  var _b = _a, {
    id,
    onKeyDown,
    ref: forwardedRef
  } = _b, props = __objRest(_b, [
    "id",
    "onKeyDown",
    "ref"
  ]);
  let {
    dispatch,
    triggerRef,
    dropdownRef,
    selectCallbacks,
    dropdownId,
    state: { isExpanded, triggerId, selectionIndex, typeaheadQuery }
  } = useDropdownContext("useDropdownItems");
  let items = useDropdownDescendants();
  let ref = (0, import_utils.useComposedRefs)(dropdownRef, forwardedRef);
  React.useEffect(() => {
    let match = findItemFromTypeahead(items, typeaheadQuery);
    if (typeaheadQuery && match != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: match,
          dropdownRef
        }
      });
    }
    let timeout = window.setTimeout(() => typeaheadQuery && dispatch({ type: SEARCH_FOR_ITEM, payload: "" }), 1e3);
    return () => window.clearTimeout(timeout);
  }, [dispatch, items, typeaheadQuery, dropdownRef]);
  let prevItemsLength = (0, import_utils.usePrevious)(items.length);
  let prevSelected = (0, import_utils.usePrevious)(items[selectionIndex]);
  let prevSelectionIndex = (0, import_utils.usePrevious)(selectionIndex);
  React.useEffect(() => {
    if (selectionIndex > items.length - 1) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.length - 1,
          dropdownRef
        }
      });
    } else if (prevItemsLength !== items.length && selectionIndex > -1 && prevSelected && prevSelectionIndex === selectionIndex && items[selectionIndex] !== prevSelected) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.findIndex((i) => i.key === (prevSelected == null ? void 0 : prevSelected.key)),
          dropdownRef
        }
      });
    }
  }, [
    dropdownRef,
    dispatch,
    items,
    prevItemsLength,
    prevSelected,
    prevSelectionIndex,
    selectionIndex
  ]);
  let handleKeyDown = (0, import_utils.composeEventHandlers)(function handleKeyDown2(event) {
    let { key } = event;
    if (!isExpanded) {
      return;
    }
    switch (key) {
      case "Enter":
      case " ":
        let selected = items.find((item) => item.index === selectionIndex);
        if (selected && !selected.disabled) {
          event.preventDefault();
          if (selected.isLink && selected.element) {
            selected.element.click();
          } else {
            focus(triggerRef.current);
            selectCallbacks.current[selected.index] && selectCallbacks.current[selected.index]();
            dispatch({ type: CLICK_MENU_ITEM });
          }
        }
        break;
      case "Escape":
        focus(triggerRef.current);
        dispatch({ type: CLOSE_MENU });
        break;
      case "Tab":
        event.preventDefault();
        break;
      default:
        if ((0, import_utils.isString)(key) && key.length === 1) {
          let query = typeaheadQuery + key.toLowerCase();
          dispatch({
            type: SEARCH_FOR_ITEM,
            payload: query
          });
        }
        break;
    }
  }, (0, import_descendants.useDescendantKeyDown)(DropdownDescendantContext, {
    currentIndex: selectionIndex,
    orientation: "vertical",
    rotate: false,
    filter: (item) => !item.disabled,
    callback: (index) => {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    },
    key: "index"
  }));
  return {
    data: {
      activeDescendant: useItemId(selectionIndex) || void 0,
      triggerId
    },
    props: __spreadProps(__spreadValues({
      tabIndex: -1
    }, props), {
      ref,
      id: dropdownId,
      onKeyDown: (0, import_utils.composeEventHandlers)(onKeyDown, handleKeyDown)
    })
  };
}
var DropdownItems = React.forwardRef((_a, forwardedRef) => {
  var _b = _a, { as: Comp = "div" } = _b, rest = __objRest(_b, ["as"]);
  let { props } = useDropdownItems(__spreadProps(__spreadValues({}, rest), { ref: forwardedRef }));
  return /* @__PURE__ */ React.createElement(Comp, __spreadValues({
    "data-reach-dropdown-items": ""
  }, props));
});
DropdownItems.displayName = "DropdownItems";
function useDropdownPopover(_a) {
  var _b = _a, {
    onBlur,
    portal = true,
    position,
    ref: forwardedRef
  } = _b, props = __objRest(_b, [
    "onBlur",
    "portal",
    "position",
    "ref"
  ]);
  let {
    triggerRef,
    triggerClickedRef,
    dispatch,
    dropdownRef,
    popoverRef,
    state: { isExpanded }
  } = useDropdownContext("useDropdownPopover");
  let ref = (0, import_utils.useComposedRefs)(popoverRef, forwardedRef);
  React.useEffect(() => {
    if (!isExpanded) {
      return;
    }
    let ownerDocument = (0, import_utils.getOwnerDocument)(popoverRef.current);
    function listener(event) {
      if (triggerClickedRef.current) {
        triggerClickedRef.current = false;
      } else if (!popoverContainsEventTarget(popoverRef.current, event.target)) {
        dispatch({ type: CLOSE_MENU });
      }
    }
    ownerDocument.addEventListener("mousedown", listener);
    return () => {
      ownerDocument.removeEventListener("mousedown", listener);
    };
  }, [
    triggerClickedRef,
    triggerRef,
    dispatch,
    dropdownRef,
    popoverRef,
    isExpanded
  ]);
  return {
    data: {
      portal,
      position,
      targetRef: triggerRef,
      isExpanded
    },
    props: __spreadValues({
      ref,
      hidden: !isExpanded,
      onBlur: (0, import_utils.composeEventHandlers)(onBlur, (event) => {
        if (event.currentTarget.contains(event.relatedTarget)) {
          return;
        }
        dispatch({ type: CLOSE_MENU });
      })
    }, props)
  };
}
var DropdownPopover = React.forwardRef((_a, forwardedRef) => {
  var _b = _a, { as: Comp = "div" } = _b, rest = __objRest(_b, ["as"]);
  let {
    data: { portal, targetRef, position },
    props
  } = useDropdownPopover(__spreadProps(__spreadValues({}, rest), { ref: forwardedRef }));
  let sharedProps = {
    "data-reach-dropdown-popover": ""
  };
  return portal ? /* @__PURE__ */ React.createElement(import_popover.Popover, __spreadProps(__spreadValues(__spreadValues({}, props), sharedProps), {
    as: Comp,
    targetRef,
    position,
    unstable_skipInitialPortalRender: true
  })) : /* @__PURE__ */ React.createElement(Comp, __spreadValues(__spreadValues({}, props), sharedProps));
});
DropdownPopover.displayName = "DropdownPopover";
function findItemFromTypeahead(items, string = "") {
  if (!string) {
    return null;
  }
  let found = items.find((item) => {
    var _a, _b, _c;
    return item.disabled ? false : (_c = (_b = (_a = item.element) == null ? void 0 : _a.dataset) == null ? void 0 : _b.valuetext) == null ? void 0 : _c.toLowerCase().startsWith(string);
  });
  return found ? items.indexOf(found) : null;
}
function useItemId(index) {
  let { dropdownId } = useDropdownContext("useItemId");
  return index != null && index > -1 ? (0, import_utils.makeId)(`option-${index}`, dropdownId) : void 0;
}
function focus(element) {
  element && element.focus();
}
function popoverContainsEventTarget(popover, target) {
  return !!(popover && popover.contains(target));
}
function reducer(state, action = {}) {
  switch (action.type) {
    case CLICK_MENU_ITEM:
      return __spreadProps(__spreadValues({}, state), {
        isExpanded: false,
        selectionIndex: -1
      });
    case CLOSE_MENU:
      return __spreadProps(__spreadValues({}, state), {
        isExpanded: false,
        selectionIndex: -1
      });
    case OPEN_MENU_AT_FIRST_ITEM:
      return __spreadProps(__spreadValues({}, state), {
        isExpanded: true,
        selectionIndex: 0
      });
    case OPEN_MENU_AT_INDEX:
      return __spreadProps(__spreadValues({}, state), {
        isExpanded: true,
        selectionIndex: action.payload.index
      });
    case OPEN_MENU_CLEARED:
      return __spreadProps(__spreadValues({}, state), {
        isExpanded: true,
        selectionIndex: -1
      });
    case SELECT_ITEM_AT_INDEX: {
      let { dropdownRef = { current: null } } = action.payload;
      if (action.payload.index >= 0 && action.payload.index !== state.selectionIndex) {
        if (dropdownRef.current) {
          let doc = (0, import_utils.getOwnerDocument)(dropdownRef.current);
          if (dropdownRef.current !== (doc == null ? void 0 : doc.activeElement)) {
            dropdownRef.current.focus();
          }
        }
        return __spreadProps(__spreadValues({}, state), {
          selectionIndex: action.payload.max != null ? Math.min(Math.max(action.payload.index, 0), action.payload.max) : Math.max(action.payload.index, 0)
        });
      }
      return state;
    }
    case CLEAR_SELECTION_INDEX:
      return __spreadProps(__spreadValues({}, state), {
        selectionIndex: -1
      });
    case SET_BUTTON_ID:
      return __spreadProps(__spreadValues({}, state), {
        triggerId: action.payload
      });
    case SEARCH_FOR_ITEM:
      if (typeof action.payload !== "undefined") {
        return __spreadProps(__spreadValues({}, state), {
          typeaheadQuery: action.payload
        });
      }
      return state;
    default:
      return state;
  }
}
function useDropdownDescendants() {
  return (0, import_descendants.useDescendants)(DropdownDescendantContext);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DropdownItem,
  DropdownItems,
  DropdownPopover,
  DropdownProvider,
  DropdownTrigger,
  useDropdownContext,
  useDropdownDescendants,
  useDropdownItem,
  useDropdownItems,
  useDropdownPopover,
  useDropdownTrigger
});
//# sourceMappingURL=reach-dropdown.cjs.dev.js.map